import { isCSSRequest } from "../core/render/util.js";
import { getPageDataByViteID, getPageDatasByClientOnlyID } from "../core/build/internal.js";
import { resolvedPagesVirtualModuleId } from "../core/app/index.js";
import crypto from "crypto";
function rollupPluginAstroBuildCSS(options) {
  const { internals } = options;
  function* walkParentInfos(id, ctx, seen = /* @__PURE__ */ new Set()) {
    seen.add(id);
    const info = ctx.getModuleInfo(id);
    if (info) {
      yield info;
    }
    const importers = ((info == null ? void 0 : info.importers) || []).concat((info == null ? void 0 : info.dynamicImporters) || []);
    for (const imp of importers) {
      if (seen.has(imp)) {
        continue;
      }
      yield* walkParentInfos(imp, ctx, seen);
    }
  }
  function* getTopLevelPages(id, ctx) {
    for (const info of walkParentInfos(id, ctx)) {
      const importers = ((info == null ? void 0 : info.importers) || []).concat((info == null ? void 0 : info.dynamicImporters) || []);
      if (importers.length <= 2 && importers[0] === resolvedPagesVirtualModuleId) {
        yield info.id;
      }
    }
  }
  function createHashOfPageParents(id, ctx) {
    const parents = Array.from(getTopLevelPages(id, ctx)).sort();
    const hash = crypto.createHash("sha256");
    for (const page of parents) {
      hash.update(page, "utf-8");
    }
    return hash.digest("hex").slice(0, 8);
  }
  function* getParentClientOnlys(id, ctx) {
    for (const info of walkParentInfos(id, ctx)) {
      yield* getPageDatasByClientOnlyID(internals, info.id);
    }
  }
  return {
    name: "@astrojs/rollup-plugin-build-css",
    configResolved(resolvedConfig) {
      const plugins = resolvedConfig.plugins;
      const viteCSSPostIndex = resolvedConfig.plugins.findIndex((p) => p.name === "vite:css-post");
      if (viteCSSPostIndex !== -1) {
        const viteCSSPost = plugins[viteCSSPostIndex];
        const renderChunk = viteCSSPost.renderChunk;
        if (renderChunk) {
          viteCSSPost.renderChunk = async function(...args) {
            const minifyOption = resolvedConfig.build.minify;
            if (minifyOption === false) {
              resolvedConfig.build.minify = "esbuild";
            }
            const result = await renderChunk.apply(this, args);
            if (typeof result === "string") {
              return {
                code: result
              };
            }
            resolvedConfig.build.minify = minifyOption;
            return result || null;
          };
        }
        const ourIndex = plugins.findIndex((p) => p.name === "@astrojs/rollup-plugin-build-css");
        const ourPlugin = plugins[ourIndex];
        plugins.splice(ourIndex, 1);
        plugins.splice(viteCSSPostIndex - 1, 0, ourPlugin);
      }
    },
    outputOptions(outputOptions) {
      const manualChunks = outputOptions.manualChunks || Function.prototype;
      outputOptions.manualChunks = function(id, ...args) {
        if (typeof manualChunks == "object") {
          if (id in manualChunks) {
            return manualChunks[id];
          }
        } else if (typeof manualChunks === "function") {
          const outid = manualChunks.call(this, id, ...args);
          if (outid) {
            return outid;
          }
        }
        if (isCSSRequest(id)) {
          return createHashOfPageParents(id, args[0]);
        }
      };
    },
    async generateBundle(_outputOptions, bundle) {
      for (const [_, chunk] of Object.entries(bundle)) {
        if (chunk.type === "chunk") {
          const c = chunk;
          if ("viteMetadata" in chunk) {
            const meta = chunk["viteMetadata"];
            if (meta.importedCss.size) {
              if (options.target === "client") {
                for (const [id] of Object.entries(c.modules)) {
                  for (const pageData of getParentClientOnlys(id, this)) {
                    for (const importedCssImport of meta.importedCss) {
                      pageData.css.add(importedCssImport);
                    }
                  }
                }
              }
              for (const [id] of Object.entries(c.modules)) {
                for (const pageViteID of getTopLevelPages(id, this)) {
                  const pageData = getPageDataByViteID(internals, pageViteID);
                  for (const importedCssImport of meta.importedCss) {
                    pageData == null ? void 0 : pageData.css.add(importedCssImport);
                  }
                }
              }
            }
          }
        }
        if (chunk.type === "chunk") {
          const exp = new RegExp(`(\\bimport\\s*)[']([^']*(?:[a-z]+.[0-9a-z]+.m?js))['](;
?)`, "g");
          chunk.code = chunk.code.replace(exp, (_match, begin, chunkPath, end) => {
            return begin + '"' + chunkPath + '"' + end;
          });
        }
      }
    }
  };
}
export {
  rollupPluginAstroBuildCSS
};
